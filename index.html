<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Ğ¢Ñ€Ğ°Ğ½ÑĞ»Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ ZIP-Ğ°Ñ€Ñ…Ğ¸Ğ²Ğ°</title>
  <style>
    body { font-family: sans-serif; margin: 2em; background: #f9f9f9; }
    h1 { color: #333; }
    input, button { margin-top: 1em; display: block; }
    #log { margin-top: 2em; white-space: pre-wrap; background: #eee; padding: 1em; border-radius: 8px; height: 300px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>ZIP Ğ¢Ñ€Ğ°Ğ½ÑĞ»Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€: ğŸ‡·ğŸ‡º â‡„ ğŸ‡¬ğŸ‡§</h1>
  <p>Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚Ğµ ZIP-Ğ°Ñ€Ñ…Ğ¸Ğ² Ñ ĞºĞ¸Ñ€Ğ¸Ğ»Ğ»Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼Ğ¸ Ğ¸Ğ»Ğ¸ Ğ»Ğ°Ñ‚Ğ¸Ğ½ÑĞºĞ¸Ğ¼Ğ¸ Ğ¸Ğ¼ĞµĞ½Ğ°Ğ¼Ğ¸. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ.</p>

  <input type="file" id="zipInput" accept=".zip" />
  <select id="mode">
    <option value="forward">ğŸ‡·ğŸ‡º â†’ ğŸ‡¬ğŸ‡§ Ğ¢Ñ€Ğ°Ğ½ÑĞ»Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ</option>
    <option value="reverse">ğŸ‡¬ğŸ‡§ â†’ ğŸ‡·ğŸ‡º ĞĞ±Ñ€Ğ°Ñ‚Ğ½Ğ°Ñ Ñ‚Ñ€Ğ°Ğ½ÑĞ»Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ</option>
  </select>
  <button onclick="processZip()">ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ</button>

  <div id="log">ğŸ“ Ğ–ÑƒÑ€Ğ½Ğ°Ğ» Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹ Ğ¿Ğ¾ÑĞ²Ğ¸Ñ‚ÑÑ Ğ·Ğ´ĞµÑÑŒ...</div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const translitTable = {
      "Ğ":"A","Ğ‘":"B","Ğ’":"V","Ğ“":"G","Ğ”":"D","Ğ•":"E","Ğ":"E","Ğ–":"Zh","Ğ—":"Z","Ğ˜":"I","Ğ™":"Y",
      "Ğš":"K","Ğ›":"L","Ğœ":"M","Ğ":"N","Ğ":"O","ĞŸ":"P","Ğ ":"R","Ğ¡":"S","Ğ¢":"T","Ğ£":"U","Ğ¤":"F",
      "Ğ¥":"Kh","Ğ¦":"Ts","Ğ§":"Ch","Ğ¨":"Sh","Ğ©":"Sch","Ğª":"","Ğ«":"Y","Ğ¬":"","Ğ­":"E","Ğ®":"Yu","Ğ¯":"Ya",
      "Ğ°":"a","Ğ±":"b","Ğ²":"v","Ğ³":"g","Ğ´":"d","Ğµ":"e","Ñ‘":"e","Ğ¶":"zh","Ğ·":"z","Ğ¸":"i","Ğ¹":"y",
      "Ğº":"k","Ğ»":"l","Ğ¼":"m","Ğ½":"n","Ğ¾":"o","Ğ¿":"p","Ñ€":"r","Ñ":"s","Ñ‚":"t","Ñƒ":"u","Ñ„":"f",
      "Ñ…":"kh","Ñ†":"ts","Ñ‡":"ch","Ñˆ":"sh","Ñ‰":"sch","ÑŠ":"","Ñ‹":"y","ÑŒ":"","Ñ":"e","Ñ":"yu","Ñ":"ya"
    };
    const reverseTable = Object.fromEntries(Object.entries(translitTable).map(([k, v]) => [v, k]));

    const log = (text) => {
      document.getElementById("log").textContent += `\n${text}`;
    };

    function transliterate(text, mode) {
      if (mode === "forward") {
        return text.split('').map(ch => translitTable[ch] || ch).join('');
      } else {
        return text.replace(/Zh|Sch|Kh|Ts|Ch|Sh|Yu|Ya|zh|sch|kh|ts|ch|sh|yu|ya|[A-Za-z]/g, match =>
          Object.entries(translitTable).find(([, v]) => v === match)?.[0] || match
        );
      }
    }

    async function processZip() {
      const file = document.getElementById("zipInput").files[0];
      const mode = document.getElementById("mode").value;
      const zip = new JSZip();
      const output = new JSZip();
      document.getElementById("log").textContent = "ğŸ”„ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ...";

      try {
        const zipData = await zip.loadAsync(file);
        log("âœ… ZIP-Ñ„Ğ°Ğ¹Ğ» Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½. Ğ¤Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸: " + Object.keys(zipData.files).length);

        for (let filePath in zipData.files) {
          const fileObj = zipData.files[filePath];
          const newPath = filePath.split("/").map(part => transliterate(part, mode)).join("/");

          if (!fileObj.dir) {
            const content = await fileObj.async("uint8array");
            output.file(newPath, content);
            log(`ğŸ“„ ${filePath} â†’ ${newPath}`);
          } else {
            output.folder(newPath);
            log(`ğŸ“ ${filePath} â†’ ${newPath}`);
          }
        }

        const result = await output.generateAsync({ type: "blob" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(result);
        link.download = "transliterated.zip";
        link.textContent = "â¬‡ï¸ Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ ZIP Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ¼";
        document.body.appendChild(link);
        log("âœ… ĞÑ€Ñ…Ğ¸Ğ² ÑĞ¾Ğ·Ğ´Ğ°Ğ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº ÑĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ.");
      } catch (err) {
        log("âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: " + err.message);
      }
    }
  </script>
</body>
</html>